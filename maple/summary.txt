The language of mapreductions:

  A mapreduction mr denotes a monoid along with a map from indices (i) to
  monoid elements (such as e being t[i]).  There is an implicit index 'i',
  allowed to appear in e and cond.

  mr ::= Fanout(mr,mr) | Index(n,o,e,mr) | Split(cond,mr,mr) | Unit() | Add(e)

  Unit() denotes the trivial monoid along with the constant map.
  Add(e) denotes the monoid of numbers under addition,
    along with the map i->e.
  Fanout(mr1,mr2) and Split(cond,mr1,mr2) both denote the product monoid of
    the monoids denoted by mr1 and by mr2.  But if the maps denoted by
    mr1 and mr2 are map1 and map2 then Fanout(mr1,mr2) denotes the map
    i->[map1(i),map2(i)] whereas Split(cond,mr1,mr2) denotes the map
    i->piecewise(cond,[map1(i),identity],[identity,map2(i)]).
  Index(n,o,e,mr(o)) denotes the product monoid of the monoids denoted by
    mr(0)..mr(n-1), along with a map that returns a tuple that is
    all identity except at o = e.

Run-time helpers:

  Loop(mr, i=rng) =
    summary := Init(mr);
    for iv=rng do Accum(i, iv, mr, summary) end do;
    return summary

  Init(Fanout(mr1, mr2))      = [Init(mr1), Init(mr2)]
  Init(Index(n, o, e, mr))    = [seq(Init(mr), o=0..n-1)]
  Init(Split(cond, mr1, mr2)) = [Init(mr1), Init(mr2)]
  Init(Unit())                = []
  Init(Add(e))                = 0

  Accum(i, iv, Fanout(mr1, mr2), summary) =
    Accum(i, iv, mr1, summary[1]);
    Accum(i, iv, mr2, summary[2]);
  Accum(i, iv, Index(n, o, e, mr), summary) =
    ov := eval(e, i=iv);
    if o::nonnegint and o<n then Accum(i, iv, mr, summary[ov+1]) end if;
  Accum(i, iv, Split(cond, mr1, mr2), summary) =
    if eval(cond, i=iv) then Accum(i, iv, mr1, summary[1])
                        else Accum(i, iv, mr2, summary[2]) end if;
  Accum(i, iv, Unit(), summary) = ;
  Accum(i, iv, Add(e), summary) = summary += eval(e, i=iv);

Specification:

  If [mr, f] = summarize(e, kb, i)
  then f(Loop(mr, i=rng)) = sum(e, i=rng)
  and we try to make mr depend on as little as possible

Implementation:

  summarize(C[piecewise(cond,a,b)], kb, i) =
    [Fanout(mr1, mr2),
     summary -> piecewise(cond, f1(summary[1]), f2(summary[2]))]
    where [mr1, f1] = summarize(C[a], kb, i)
          [mr2, f2] = summarize(C[b], kb, i)
    if not depends(cond, i)

  Choose between the two rules below by outermosting the variables in
    indets(e,name) minus {i}  versus  indets(cond,name) minus {i}

  summarize(piecewise(o=e,a,0), kb, i) =
    [Index(n, o, e, mr),
     summary -> piecewise(o::nonnegint and o<n, f(summary[o+1]), 0)]
    where [mr, f] = summarize(a, kb, i)
    if not depends(o, i) and kb entails o::nonnegint and o<n

  summarize(C[piecewise(cond,a,b)], kb, i) =
    [Split(cond, mr1, mr2),
     summary -> f1(summary[1]) + f2(summary[2])]
    where [mr1, f1] = summarize(C[a], kb, i)
          [mr2, f2] = summarize(C[b], kb, i)

  summarize(0, kb, i) = [Unit(), summary -> 0]

  summarize(e, kb, i) = [Add(e), summary -> summary]

Example:

  # First "summate i" in offshore under gmm_gibbs.hk
  summarize(piecewise(_b=piecewise(i=docUpdate,zNew,z[i]),t[i],0), kb, i)
  = [Split(i=docUpdate, Fanout(Add(t[i]), Unit()),
                        Index(size(as), _b, z[i], Add(t[i]))),
     summary -> piecewise(_b=zNew, summary[1], 0) + summary[_b+1]]

      Recursive call to summarize assuming i=docUpdate is true:
      summarize(piecewise(_b=zNew,t[i],0), kb, i)
      = [Fanout(Add(t[i]), Unit()), summary -> piecewise(_b=zNew, summary[1], 0)]

      Recursive call to summarize assuming i=docUpdate is false:
      summarize(piecewise(_b=z[i],t[i],0), kb, i)
      = [Index(size(as), _b, z[i], Add(t[i])), summary -> summary[_b+1]]

          summarize(t[i], kb, i)
          = [Add(t[i]), summary -> summary]

  # First "summate j" in offshore under naive_bayes_gibbs.hk
  summarize(piecewise(doc[j]=docUpdate,piecewise(k=zNew,piecewise(i=w[j],1,0),0),0), kb, j)
  = [Fanout(Index(size(word_prior), i, w[j], Index(size(z), docUpdate, doc[j], Add(1))),
            Index(size(z), docUpdate, doc[j], Unit())),
     summary -> piecewise(k=zNew, summary[1][w[j]+1][docUpdate+1]], 0)]

      Recursive call to summarize assuming k=zNew is true:
      summarize(piecewise(doc[j]=docUpdate,piecewise(i=w[j],1,0),0), kb, j)
      = [Index(size(word_prior), i, w[j], Index(size(z), docUpdate, doc[j], Add(1))),
         summary -> summary[w[j]+1][docUpdate+1]]

          Recursive call to summarize assuming i=w[j]:
          summarize(piecewise(doc[j]=docUpdate,1,0), kb, j)
          = [Index(size(z), docUpdate, doc[j], Add(1)),
             summary -> summary[docUpdate+1]]

      Recursive call to summarize assuming k=zNew is false:
      summarize(piecewise(doc[j]=docUpdate,0,0), kb, j)
      = [Index(size(z), docUpdate, doc[j], Unit()),
         summary -> 0]
