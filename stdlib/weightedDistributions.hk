def zeta(alpha prob):
	x<~counting
	if (x>-1):
		x = int2nat(x)
		pmf = 1 / (x**alpha * 3 *(summate i from 1 to ∞: (1/i)**alpha))
		weight(pmf, return x)
	else:
		return 0

def powerSeries(a (nat->prob), c prob):
	if (c>0):
		x<~counting
		if (x>-1):
			x = int2nat(x)
			pmf = a(x)*c**x / (summate i from 0 to ∞: a(i)*c**i)
			weight(pmf, return x)
		else:
			return 0
	else:
		reject.measure(nat)


def TSP(a real,b real,m real,n prob):
	if (m>a && b>m && n>0):	
		x<~lebesgue(0,∞)
		x = real2prob(x)
		pdf = if (x>a && x<m): (n*real2prob(x-a)**(n-1))/(real2prob(b-a)*real2prob(m-a)**(n-1)) 
			  else: if x>=m && x<b : (n*real2prob(b-x)**(n-1))/(real2prob(b-a)*real2prob(b-m)**(n-1)) 
			  else: 0 
		return pdf
	else:
		reject.measure(prob)

def muth(kappa prob):
	x<~lebesgue(0,∞)
	if (x>0 && kappa>0 && kappa<=1):
		x = real2prob(x)
		pdf = real2prob(exp(kappa*x)-kappa)*exp(-(exp(kappa*x)/kappa)+kappa*x+1/kappa)
		weight(real2prob(pdf), return x)
	else:
		reject.measure(prob)

muth(1)

