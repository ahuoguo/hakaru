# Hakaru Standard Library
# author: Aryan Sohrabi 

##############################
# Symbolic Distributions #
##############################

# These distributions are to be used for symbolic manipulation and not for sampling

# The PDF/PMF of these distributions were taken from: http://www.math.wm.edu/~leemis/chart/UDR/UDR.html

#The Zeta Distribution
# TODO: use zetaFunc instead of the explicit summate?
def zeta(alpha prob) measure(nat):
    x<~counting
    if (x>-1):
        x = int2nat(x)
        w = summate i from 1 to ∞: (1/i)**alpha
        pmf = 1 / (x**alpha * 3 * w)
        weight(pmf, return x)
    else:
        reject.measure(nat)

# The Power Series distribution (given by a sequence of weights).
#  WARNING: do not try to Sample this, it will fail!!
def powerSeries(a (nat->prob), c prob) measure(nat):
    if (c>0):
        x<~counting
        if (x>-1):
            x = int2nat(x)
            pmf = a(x)*c**x / (summate i from 0 to ∞: a(i)*c**i)
            weight(pmf, return x)
        else:
            reject.measure(nat)
    else:
        reject.measure(nat)
#The Muth Distribution
def muth(kappa prob) measure(prob):
    x<~lebesgue(0,∞)
    if (x>0 && kappa>0 && kappa<=1):
        x = real2prob(x)
        pdf = real2prob(exp(kappa*x)-kappa)*exp(-(exp(kappa*x)/kappa)+kappa*x+1/kappa)
        weight(real2prob(pdf), return x)
    else:
        reject.measure(prob)

#The TSP Distribution
def TSP(a real,b real,m real,n prob) measure(prob):
    if (m>a && b>m && n>0): 
        x<~lebesgue(0,∞)
        x = real2prob(x)
        pdf = if (x>a && x<m): (n*real2prob(x-a)**(n-1))/(real2prob(b-a)*real2prob(m-a)**(n-1)) 
              else: if x>=m && x<b : (n*real2prob(b-x)**(n-1))/(real2prob(b-a)*real2prob(b-m)**(n-1)) 
              else: 0 
        weight(real2prob(pdf), return x)
    else:
        reject.measure(prob)