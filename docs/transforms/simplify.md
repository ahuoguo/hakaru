# Hakaru-Maple #

Hakaru uses the computer algebra system Maple to aid in performing program
transformations. You can use this functionality of Hakaru if you have Maple
installed locally or can access Maple remotely. 

Maple can be accessed through the module `Language.Hakaru.Maple` or through the
Hakaru program `hk-maple`.

The `hk-maple` command invokes a Maple command on a Hakaru program. Given a
Hakaru program in concrete syntax and a Maple-Hakaru command, typecheck the
program invoke the Maple command on the program and its type pretty print, parse
and typecheck the program resulting from Maple. See the `--help` flag of
`hk-maple` for more information.

The currently available Maple-Hakaru commands (also called subcommands):

- Simplify 
- Disintegrate 
- Summarize 

Note: calls to Maple may take a very long time. To see if your program is taking
an appreciable amount of time to parse and typecheck, use the `--debug` flag.

## Subcommands 
### Simplify
Hakaru programs are interpreted by Maple as linear operators. In this
interpretation, many commonly understood (by Maple) and powerful tools for
simplification become available. The metric for simplification as understood by
this command is sampling efficiency. `Simplify` attempts to be as conservative
as possible in changing the given program. In particular, it should not change
terms unless an improvement with respect to sampling is performed; in this case,
arbitrary rearrangement may happen, even if an expression more similair to the
original could be produced.

`Simplify` is the default subcommand.

`Simplify` preserves the semantics of the given program up to normalization of
weights. If the stronger sense of equivalence is needed, the output of
`Simplify` can be passed to `normalize`. 

Historical note: the `Simplify` subcommand of `hk-maple` used to be known as a
seperate command named `simplify`. If you encounter `simplify someprog.hk
<options>` in this documentation, you may replace it by `hk-maple someprog.hk
<options>`.

### Disintegrate
The Maple disintegrator is an alternative implementation of the program
transformation described in [Disintegrate]. Semantically, the Maple
disintegrator and Haskell disintegrator implement the same transformation. In
particular, their outputs are not (often) identical, but have equivalent
sampling semantics. In practice, the ouputs may differ, since one may fail where
the other succeeds. 

If in doubt about which disintegrator to use, consider the following order:

1. `disintegrate x`
2. `disintegrate x | hk-maple -`
3. `hk-maple --command disintegrate x`
4. `hk-maple x | disintegrate -` 
5. etc...

All of the above programs should be equivalent as samplers. 

The disintegrator internally relies heavily on the `Simplify` command, so if the
given problem is an easy disintegration problem but a difficult simplification
problem, it is preferred to use the Haskell disintegrator followed by a call
to `Simplify`.

The chance that the Maple disintegrator produces a good program (or any program
at all) is proportional to the type of program it is given. In addition to
programs whose disintegration by Haskell is not efficient as a sampler, the
following programs are good candidates:

- programs which contain superpositions with complicated conditions
- programs which contain complicated rational polynomials 

The Maple disintegrator follows the same conventions as the Haskell
disintegrator.

Like `Simplify`, `Disintegrate` preserves the semantics of the given program only up to
normalization of weights.

### Summarize

?

## Example ##

This program takes in a value of type `prob` and returns a measure of type `real`:

````nohighlight
fn a prob:
  x <~ normal(a,1)
  y <~ normal(x,1)
  z <~ normal(y,1)
  return z
````

The returned value, `z`, is generated by passing the last value generated by the function, starting with the original function argument. This indicates that it might be 
reducible to a smaller program. Assuming that we named the program `simplify_before.hk`, we can call the `Simplify` transform by running:

````bash
hk-maple simplify_before.hk
````

**Note:** The output for `Simplify` will be printed in the console. You can easily save this program to a file by redirecting the output to a file by calling 
`hk-maple model1.hk > model2.hk`. For this example, we will call our new program `simplify_after.hk`. 

When you open our new program, `simplify_after.hk`, you will see that the original five-line program has been reduced to a single line:

````nohighlight
fn a prob: normal(prob2real(a), sqrt(3))
````
